# HashtableImplementationByC
Implement hashtable by C.

## ğŸ’ğŸ»â€â™‚ï¸ êµ¬í˜„í•˜ê¸° ì•ì„œ
### í•´ì‹œí…Œì´ë¸”ì— ëŒ€í•œ ê°„ë‹¨í•œ ì„¤ëª…
í•´ì‹œí…Œì´ë¸”ì€ ë°ì´í„°ì˜ ì–‘ì´ ë§ì„ ê²½ìš° ìƒê¸°ëŠ” ë°ì´í„° ê²€ìƒ‰ì— ëŒ€í•œ ì—°ì‚°ê³¼ì •ì„ ì¤„ì¼ ìˆ˜ ìˆëŠ” ìë£Œêµ¬ì¡°ì´ë‹¤. keyê°€ ì£¼ì–´ì¡Œì„ ë•Œ valueë¥¼ ì°¾ê¸° ìœ„í•œ ë°©ë²•ìœ¼ë¡œ í•´ì‹œ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•œë‹¤. input ìœ¼ë¡œ keyê°€ ë“¤ì–´ì˜¤ë©´ í•´ì‰¬ í•¨ìˆ˜ë¥¼ í†µí•œ í•´ì‰¬ ì¸ë±ìŠ¤ê°€ ë‚˜ì˜¤ê³  í•´ë‹¹ ì¸ë±ìŠ¤ë¥¼ í†µí•´ ë¹ ë¥´ê²Œ ë°ì´í„°ë¥¼ ì°¾ì•„ ë“¤ì–´ê°€ëŠ” êµ¬ì¡°ì´ë‹¤. ê·¸ë¦¼ì„ ë³´ì.
![](https://images.velog.io/images/jewelrykim/post/ebfeab31-1336-4cf4-8dd7-5ead9f13c3e9/%E1%84%92%E1%85%A2%E1%84%89%E1%85%B1%E1%84%87%E1%85%A5%E1%84%8F%E1%85%A6%E1%86%BA.001.jpeg)
í‚¤ì™€ í•´ì‹œí•¨ìˆ˜ë¥¼ í†µí•´ ì–»ì€ í•´ì‹œ ì¸ë±ìŠ¤ë¡œ Bucketì˜ ì¸ë±ìŠ¤ë¥¼ ì°¾ëŠ”ë‹¤. ê·¸ ë’¤ì— í‚¤ì™€ ë°ì´í„°ê°€ ì €ì¥ëœ ë…¸ë“œë¥¼ ë²„ì¼“ ë’¤ì— ë¶™ì´ëŠ” í˜•ì‹ì´ë‹¤. ë‹¨ìˆœ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í–ˆì„ ë•Œ ê°’ì„ ì°¾ê¸°ìœ„í•´ ëª¨ë“  ë…¸ë“œë¥¼ ìˆœíšŒí•´ì•¼í•˜ëŠ” ë°˜ë©´ í•´ì‰¬ í…Œì´ë¸”ì€ í‚¤ë¥¼ í†µí•´ ë°”ë¡œ í•´ì‹œ ì¸ë±ìŠ¤ë¡œ ì ‘ê·¼í•  ìˆ˜ ìˆìœ¼ë¯€ë¡œ ì‹œê°„ ë³µì¡ë„ê°€ ì¤„ì–´ë“¦ì„ ì•Œ ìˆ˜ ìˆë‹¤. ë‹¤ë§Œ, ìœ„ ê·¸ë¦¼ì—ì„œ ìœ ì¶”í•  ìˆ˜ ìˆë“¯ì´ í•œ ì¸ë±ìŠ¤ë¡œ ë…¸ë“œê°€ ëª¨ë‘ ëª°ë¦¬ëŠ” ê²½ìš°ê°€ ìƒê¸¸ ìˆ˜ë„ ìˆë‹¤. ê·¸ë ‡ê²Œ ë  ê²½ìš° ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ì™€ ë‹¤ë¥¸ ì ì´ ì—†ìœ¼ë¯€ë¡œ í•´ì‰¬í…Œì´ë¸”ì˜ ê²€ìƒ‰ì˜ ì‹œê°„ë³µì¡ë„ëŠ” ìµœì•…ì˜ ê²½ìš° O(n)ì´ ë  ìˆ˜ ìˆë‹¤.(nì€ nodeì˜ ê°œìˆ˜) ê·¸ë˜ì„œ ì¸ë±ìŠ¤ë¥¼ ë§Œë“œëŠ” í•´ì‹œ í•¨ìˆ˜ê°€ ë¬´ì—‡ë³´ë‹¤ ì¤‘ìš”í•œ ìë£Œêµ¬ì¡°ë¼ê³  í•  ìˆ˜ ìˆë‹¤.

### ì¶©ëŒ(Hash Table Collisions)
ê°€ì¥ ì´ìƒì ì¸ í•´ì‹œí…Œì´ë¸”ì€ í•œ ë²„ì¼“ì— ë”± í•œê°œì˜ ë…¸ë“œê°€ ìˆëŠ” ê²½ìš°ì´ë‹¤. ê·¸ëŸ´ ê²½ìš°ì— ë°ì´í„° ê²€ìƒ‰ì˜ ê²½ìš° ì¸ë±ìŠ¤ë§Œ ê³„ì‚°í•˜ë©´ ë°”ë¡œ ê°’ì„ ì°¾ì„ ìˆ˜ ìˆìœ¼ë¯€ë¡œ O(1)ì˜ ì‹œê°„ë³µì¡ë„ë¥¼ ë³´ì¥í•  ìˆ˜ ìˆë‹¤. í•˜ì§€ë§Œ ê·¸ë ‡ì§€ ì•Šì€ ê²½ìš°, ì¦‰, í•œ ë²„ì¼“ì— ì—¬ëŸ¬ê°œì˜ ë…¸ë“œê°€ ìˆëŠ” ê²½ìš°ë¥¼ ì¶©ëŒì´ë¼ê³  í•œë‹¤.

ì¶©ëŒì„ í•´ê²°í•˜ëŠ”ë°ì—ëŠ” í¬ê²Œ ë‘ê°€ì§€ ë°©ë²•ì´ ìˆë‹¤. ì²´ì´ë‹ê³¼ ê°œë°©ì£¼ì†Œë°©ë²•ì´ ìˆë‹¤. ì²´ì´ë‹ì€ í•´ë‹¹ ì¸ë±ìŠ¤ë¥¼ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ë¡œ ë¬¶ì–´ì„œ ê³„ì† ë’¤ì— ë§ë¶™ì´ëŠ” ì‹ìœ¼ë¡œ í•´ê²°í•˜ëŠ” ë°©ë²•ì´ê³  ìœ„ì˜ ê·¸ë¦¼ê³¼ ê°™ì€ í˜•íƒœê°€ ëœë‹¤. ë‘ë²ˆì§¸ ê°œë°©ì£¼ì†Œë°©ë²•ì€ ì¸ë±ìŠ¤ì— ì´ë¯¸ ë‹¤ë¥¸ ë…¸ë“œê°€ ìˆë‹¤ë©´ ë‹¤ë¥¸ ì¸ë±ìŠ¤ë¥¼ íƒìƒ‰í•´ì„œ ë¹ˆ ì¸ë±ìŠ¤ì— ì‚½ì…í•˜ëŠ” ë°©ì‹ì´ë‹¤.(ë” ìˆ¨ê²¨ì§„ ë‚´ìš©ì´ ë§ë‹¤. ë‚˜ì¤‘ì— ì•Œì•„ë³´ì)

ì›¬ë§Œí•œ lowë‹¨ì´ ì•„ë‹Œ ì–¸ì–´ë“¤ì€ í•´ì‹œ í•¨ìˆ˜ë¥¼ ê¸°ë³¸ì ìœ¼ë¡œ ì œê³µí•˜ëŠ”ë° ì—¬ê¸°ì„œëŠ” íŒŒì´ì¬ì—ì„œ ë¬¸ìì—´ì„ í•´ì‰¬í•˜ëŠ” í•¨ìˆ˜ë§Œ ì˜ˆì‹œë¡œ ë³´ì.
```c
static long string_hash(PyStringObject *a)
{
    register Py_ssize_t len;
    register unsigned char *p;
    register long x;

    if (a->ob_shash != -1)
        return a->ob_shash;
    len = Py_SIZE(a);
    p = (unsigned char *) a->ob_sval;
    x = *p << 7;
    while (--len >= 0)
        x = (1000003*x) ^ *p++;
    x ^= Py_SIZE(a);
    if (x == -1)
        x = -2;
    a->ob_shash = x;
    return x;
}
```
ë§¤ìš° ë³µì¡í•œ ê³¼ì •ì„ í†µí•´ ì¸ë±ìŠ¤ì˜ ì¤‘ë³µì„ ì—†ì• ë ¤ê³  í•¨ì„ ì•Œ ìˆ˜ ìˆë‹¤. ë”°ë¼ì„œ íŒŒì´ì¬ì—ì„œ í•´ì‹œí…Œì´ë¸”ì„ ì‚¬ìš©í•œ set, dictë¥¼ ì‚¬ìš©í•  ë•Œ ì›¬ë§Œí•œ ë°ì´í„° í¬ê¸°ë¼ë©´ ì‹œê°„ë³µì¡ë„ ê±±ì •ì„ í¬ê²Œ í•˜ì§€ ì•Šê³  ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤.
#### ì´ë²ˆ í¬ìŠ¤íŒ…ì—ì„œëŠ” ì²´ì´ë‹ì„ í†µí•´ í•´ì‹œ í…Œì´ë¸”ì„ êµ¬í˜„í•´ë³´ê³ ì í•œë‹¤.
#### ì¶”ê°€ë¡œ ì²´ì´ë‹í•  ë•Œ ë§í¬ë“œ ë¦¬ìŠ¤íŠ¸ë¥¼ singly linked listë¡œ ë§Œë“¤ê±°ë‚˜ í˜¹ì€ doubly linked listë¡œ ë§Œë“¤ìˆ˜ ìˆëŠ”ë° ë‘˜ì„ ëª¨ë‘ ë§Œë“¤ì–´ë³´ê³  ê·¸ ì°¨ì´ì ì„ ì•Œì•„ë³´ë ¤ê³  í•œë‹¤. 


### ë„ì›€ë°›ì€ ìë£Œ
[medium / @bartobri](https://medium.com/@bartobri/hash-crash-the-basics-of-hash-tables-bef82a8ea550)
[stackoverflow / Where can I find source or algorithm of Python's hash() function?](https://stackoverflow.com/questions/2070276/where-can-i-find-source-or-algorithm-of-pythons-hash-function)
[youtube / (ìë£Œêµ¬ì¡°) í•´ì‹œí…Œì´ë¸”(ë¦¬ìŠ¤íŠ¸, ì²´ì´ë‹) Cì–¸ì–´ë¡œ ì½”ë”©í•´ìš” - by Gunny
](https://www.youtube.com/watch?v=IWpJsoX_UmU)


## 1 . singly linked listë¡œ êµ¬í˜„
### ì„ ì–¸ë¶€
```c
// ì²´ì´ë‹ì„ singly linked list ë¡œ í•œ í•´ì‹œ í…Œì´ë¸” êµ¬í˜„
#include <stdio.h>
#include <stdlib.h> // ë©”ëª¨ë¦¬ í• ë‹¹ì„ ìœ„í•¨

struct bucket* hashTable = NULL; 
int BUCKET_SIZE = 10; // ë²„ì¼“ì˜ ì´ ê¸¸ì´
```
í•´ì‹œí…Œì´ë¸”ì€ ë²„ì¼“ì„ í†µí•´ ì ‘ê·¼í•˜ê¸° ë•Œë¬¸ì— hashTableì´ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ bucket ë°°ì—´ ì£¼ì†Œê°’ì„ ì„ ì–¸í•´ë‘”ë‹¤. ë²„ì¼“ì˜ ì´ ê¸¸ì´ëŠ” 10ì´ ëœë‹¤.
### êµ¬ì¡°ì²´ì„ ì–¸
```c
// ë…¸ë“œ êµ¬ì¡°ì²´ ì„ ì–¸
struct node {
    int key; // í•´ì‹œ í•¨ìˆ˜ì— ì‚¬ìš©ë  í‚¤
    int value; // key ê°€ ê°€ì§€ê³  ìˆëŠ” ë°ì´í„°
    struct node* next; // ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¥´í‚¤ëŠ” í¬ì¸í„°
};
// ë²„ì¼“ êµ¬ì¡°ì²´ ì„ ì–¸
struct bucket{
    struct node* head; // ë²„ì¼“ ê°€ì¥ ì•ì— ìˆëŠ” ë…¸ë“œì˜ í¬ì¸í„°
    int count; // ë²„ì¼“ì— ë“¤ì–´ìˆëŠ” ë…¸ë“œì˜ ê°œìˆ˜
};
```
ë…¸ë“œì™€ ë²„ì¼“ì˜ êµ¬ì¡°ì²´ë¥¼ ì„ ì–¸í•œë‹¤. 
ë…¸ë“œ - ë…¸ë“œì—ëŠ” key, valueê°€ ìˆê³  ì²´ì´ë‹ì´ ë˜ì—ˆì„ ë•Œ ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¥´í‚¤ëŠ” next í¬ì¸í„°ë¥¼ ë©¤ë²„ë¡œ ê°–ëŠ”ë‹¤.
ë²„ì¼“ - ë²„ì¼“ì—ëŠ” ë²„ì¼“ì— ìˆëŠ” ì²«ë²ˆì§¸ ë…¸ë“œì˜ í¬ì¸í„°ì™€ í•´ë‹¹ ë²„ì¼“ì— ìˆëŠ” ë…¸ë“œì˜ ê°œìˆ˜ì¸ countë¥¼ ë©¤ë²„ë¡œ ê°–ëŠ”ë‹¤.
#### ì´ì œë¶€í„° í•´ì‹œí…Œì´ë¸”ì—ì„œ í•„ìš”í•œ í•¨ìˆ˜ë¥¼ êµ¬í˜„í•´ë³´ë ¤ê³  í•œë‹¤. í•„ìš”í•œ í•¨ìˆ˜ëŠ” ë‹¤ìŒê³¼ ê°™ë‹¤.
> createNode -> ìƒˆë¡œìš´ ë…¸ë“œë¥¼ ë§Œë“¤ì–´ì£¼ëŠ” í•¨ìˆ˜
hashFunction -> í‚¤ë¥¼ í•´ì‰¬ ì¸ë±ìŠ¤ë¡œ ë³€í™˜í•´ì£¼ëŠ” í•´ì‰¬ í•¨ìˆ˜
add -> í‚¤ë¥¼ í•´ì‰¬ í…Œì´ë¸”ì— ì¶”ê°€í•˜ëŠ” í•¨ìˆ˜
remove_key -> í‚¤ë¥¼ í•´ì‰¬ í…Œì´ë¸”ì—ì„œ ì‚­ì œí•˜ëŠ” í•¨ìˆ˜
search -> í‚¤ì˜ ë°ì´í„°ê°’ì„ ì°¾ì•„ì£¼ëŠ” í•¨ìˆ˜
display -> í•´ì‰¬í…Œì´ë¸” ìì²´ë¥¼ ì¶œë ¥í•´ì„œ ë³´ì—¬ì£¼ëŠ” í•¨ìˆ˜


### createNode
```c
// í•´ì‰¬í…Œì´ë¸” ì‚½ì…ë  ë•Œ ìƒˆë¡œ ë…¸ë“œë¥¼ ìƒì„±í•´ì£¼ëŠ” í•¨ìˆ˜(ì´ˆê¸°í™”)
struct node* createNode(int key, int value){
    struct node* newNode;
    // ë©”ëª¨ë¦¬ í• ë‹¹
    newNode = (struct node *)malloc(sizeof(struct node));
    // ì‚¬ìš©ìê°€ ì „í•´ì¤€ ê°’ì„ ëŒ€ì…
    newNode->key = key;
    newNode->value = value;
    newNode->next = NULL; // ìƒì„±í•  ë•ŒëŠ” nextë¥¼ NULLë¡œ ì´ˆê¸°í™”

    return newNode;
}
```
ì‚¬ìš©ìê°€ ë„˜ê²¨ì¤€ key, valueë¡œ í•´ì‰¬í…Œì´ë¸”ì— ì¶”ê°€í•˜ê¸° ì „ì— ë…¸ë“œ êµ¬ì¡°ì²´ë¥¼ ë§Œë“¤ì–´ ì£¼ëŠ” í•¨ìˆ˜ì´ë‹¤.
### hashFunction
```c
// í•´ì‰¬í•¨ìˆ˜ ë§Œë“¤ê¸°. ì—¬ê¸°ì„œëŠ” ë‹¨ìˆœíˆ keyë¥¼ ë²„ì¼“ ê¸¸ì´ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¡œ í•¨ìˆ˜ë¥¼ ë§Œë“¦.
int hashFunction(int key){
    return key%BUCKET_SIZE;
}
```
ì¶©ëŒì„ í”¼í•œ í•´ì‰¬í•¨ìˆ˜ë¥¼ ë§Œë“œëŠ”ê²Œ ì¤‘ìš”í•˜ì§€ë§Œ ë³¸ ê¸€ì—ì„œëŠ” ì„¤ëª…ì„ ìœ„í•´ ê°„ë‹¨íˆ keyê°’ì„ bucket ê¸¸ì´ì¸ 10ìœ¼ë¡œ ë‚˜ëˆˆ ë‚˜ë¨¸ì§€ë¥¼ ì¸ë±ìŠ¤ë¡œ ë°˜í™˜í•˜ëŠ” í•´ì‹œ í•¨ìˆ˜ë¥¼ ë§Œë“¤ì–´ë³´ì•˜ë‹¤.
### add
```c
// ìƒˆë¡œ í‚¤ ì¶”ê°€í•˜ëŠ” í•¨ìˆ˜
void add(int key, int value){
    // ì–´ëŠ ë²„ì¼“ì— ì¶”ê°€í• ì§€ ì¸ë±ìŠ¤ë¥¼ ê³„ì‚°
    int hashIndex = hashFunction(key);
    // ìƒˆë¡œ ë…¸ë“œ ìƒì„±
    struct node* newNode = createNode(key, value);
    // ê³„ì‚°í•œ ì¸ë±ìŠ¤ì˜ ë²„ì¼“ì— ì•„ë¬´ ë…¸ë“œë„ ì—†ì„ ê²½ìš°
    if (hashTable[hashIndex].count == 0){
        hashTable[hashIndex].count = 1;
        hashTable[hashIndex].head = newNode; // headë¥¼ êµì²´
    }
    // ë²„ì¼“ì— ë‹¤ë¥¸ ë…¸ë“œê°€ ìˆì„ ê²½ìš° í•œì¹¸ì”© ë°€ê³  ë‚´ê°€ í—¤ë“œê°€ ëœë‹¤(ì‹¤ì œë¡œëŠ” í¬ì¸í„°ë§Œ ë°”ê¿”ì¤Œ)
    else{
        newNode->next = hashTable[hashIndex].head;
        hashTable[hashIndex].head = newNode;
        hashTable[hashIndex].count++;
    }
}
```
í‚¤ê°€ ì¶”ê°€ë  ë•Œ ì²´ì´ë‹ì˜ ì–´ëŠ ë¶€ë¶„ì— ì‚½ì…ë˜ì–´ë„ ìƒê´€ì—†ì§€ë§Œ ë³¸ ê¸€ì—ì„œëŠ” ì¶”ê°€ëœ í‚¤ê°€ í•­ìƒ ë²„ì¼“ì˜ headê°€ ë˜ë„ë¡ í•˜ì˜€ë‹¤.
### remove_key
```c
// í‚¤ë¥¼ ì‚­ì œí•´ì£¼ëŠ” í•¨ìˆ˜
void remove_key(int key){
    int hashIndex = hashFunction(key);
    // ì‚­ì œê°€ ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” flag ì„ ì–¸
    int flag = 0;
    // í‚¤ë¥¼ ì°¾ì•„ì¤„ iterator ì„ ì–¸
    struct node* node;
    struct node* before; // ë…¸ë“œê°€ ì§€ë‚˜ê°„ ë°”ë¡œ ì „ ë…¸ë“œ
    // ë²„ì¼“ì˜ headë¶€í„° ì‹œì‘
    node = hashTable[hashIndex].head;
    // ë²„ì¼“ì„ ìˆœíšŒí•˜ë©´ì„œ keyë¥¼ ì°¾ëŠ”ë‹¤.
    while (node != NULL) // NULL ì´ ë‚˜ì˜¬ë•Œê¹Œì§€ ìˆœíšŒ
    {
        if (node->key == key){
            // í¬ì¸í„° ë°”ê¿”ì£¼ê¸° ë…¸ë“œê°€ 1 . í—¤ë“œì¸ ê²½ìš° 2 . í—¤ë“œê°€ ì•„ë‹Œê²½ìš°
            if (node == hashTable[hashIndex].head){
                hashTable[hashIndex].head = node->next; // ë‹¤ìŒ ë…¸ë“œê°€ ì´ì œ í—¤ë“œ
            }
            else{
                before->next = node->next; // ì „ë…¸ë“œê°€ ì´ì œ ë‚´ ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¥´í‚´
            }
            // ë‚˜ë¨¸ì§€ ì‘ì—… ìˆ˜í–‰
            hashTable[hashIndex].count--;
            free(node);
            flag = 1;
        }
        before = node; // ë…¸ë“œ ë°”ê¿”ì£¼ê¸° ì „ì— ì €ì¥
        node = node->next;
    }
    // flagì˜ ê°’ì— ë”°ë¼ ì¶œë ¥ ë‹¤ë¥´ê²Œ í•´ì¤Œ
    if (flag == 1){ // ì‚­ì œê°€ ë˜ì—ˆë‹¤ë©´
        printf("\n [ %d ] ì´/ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤. \n", key);
    }
    else{ // í‚¤ê°€ ì—†ì–´ì„œ ì‚­ì œê°€ ì•ˆëœ ê²½ìš°
        printf("\n [ %d ] ì´/ê°€ ì¡´ì¬í•˜ì§€ ì•Šì•„ ì‚­ì œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n", key);
    }
}
```
#### remove í•¨ìˆ˜ê°€ doubly linked listë¡œ ì²´ì´ë‹ì„ êµ¬í˜„í•œ ë°©ì‹ê³¼ ê°€ì¥ í° ì°¨ì´ê°€ ìˆëŠ” ë¶€ë¶„ì´ë‹¤. 
![](https://images.velog.io/images/jewelrykim/post/2c4744ad-22fc-48ed-b8a9-6bb1a66b7fc0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.41.17.png)
ê·¸ë¦¼ê³¼ ê°™ì´ A, B, C ë…¸ë“œê°€ ì²´ì´ë‹ë˜ì–´ìˆì„ ë•Œ Bë¥¼ ì‚­ì œí•œë‹¤ê³  ê°€ì •í•´ë³´ì. ê·¸ë ‡ê²Œ ë˜ë©´ Aì˜ next í¬ì¸í„°ë¥¼ Cë¡œ ë°”ê¿”ì£¼ëŠ” ê³¼ì •ì´ í•„ìš”í•œë° ì´ë•Œ Bì—ì„œëŠ” Aë¡œ doubly linked listì™€ ë‹¬ë¦¬ ë°”ë¡œ ì ‘ê·¼í•  ìˆ˜ê°€ ì—†ìœ¼ë¯€ë¡œ í•œë²ˆ ë” searchë¥¼ í•´ì¤˜ì•¼í•˜ëŠ” ë¶ˆìƒì‚¬ê°€ ìƒê¸°ë¯€ë¡œ ì—°ì‚°ê³¼ì •ì´ ë” ë“¤ê²Œ ëœë‹¤.
#### í•˜ì§€ë§Œ ë³¸ ê¸€ remove_keyì—ì„œëŠ” ë‹¤ìŒ ë…¸ë“œë¡œ ë°˜ë³µìê°€ ì´ë™í•˜ê¸° ì „ì— ë¯¸ë¦¬ beforeì— í¬ì¸í„°ë¥¼ ì €ì¥í•´ë‘ ìœ¼ë¡œì„œ í•´ë‹¹ ì¶”ê°€ ê²€ìƒ‰ ì—°ì‚°ê³¼ì •ì„ í”¼í–ˆë‹¤.
### search í•¨ìˆ˜
```c
// í‚¤ë¥¼ ì£¼ë©´ valueë¥¼ ì•Œë ¤ì£¼ëŠ” í•¨ìˆ˜
void search(int key){
    int hashIndex = hashFunction(key);
    struct node* node = hashTable[hashIndex].head;
    int flag = 0;
    while (node != NULL)
    {
        if (node->key == key){
            flag = 1;
            break;
        }
        node = node->next;
    }
    if (flag == 1){ // í‚¤ë¥¼ ì°¾ì•˜ë‹¤ë©´
        printf("\n í‚¤ëŠ” [ %d ], ê°’ì€ [ %d ] ì…ë‹ˆë‹¤. \n", node->key, node->value);
    }
    else{
        printf("\n ì¡´ì¬í•˜ì§€ ì•Šì€ í‚¤ëŠ” ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤. \n");
    }
}
```
í•´ë‹¹ valueë¥¼ ë°˜í™˜í•˜ì§€ì•Šê³  ì¶œë ¥í•˜ëŠ” ì‹ìœ¼ë¡œ ê°„ë‹¨í•˜ê²Œ êµ¬í˜„í•´ë³´ì•˜ë‹¤.
### display í•¨ìˆ˜
```c
// í•´ì‹œí…Œì´ë¸” ì „ì²´ë¥¼ ì¶œë ¥í•´ì£¼ëŠ” í•¨ìˆ˜
void display(){
    // ë°˜ë³µì ì„ ì–¸
    struct node* iterator;
    printf("\n========= display start ========= \n");
    for (int i = 0; i<BUCKET_SIZE; i++){
        iterator = hashTable[i].head;
        printf("Bucket[%d] : ", i);
        while (iterator != NULL)
        {
            printf("(key : %d, val : %d)  -> ", iterator->key, iterator->value);
            iterator = iterator->next;
        }
        printf("\n");
    }
    printf("\n========= display complete ========= \n");
}
```
í•´ì‹œí…Œì´ë¸” ë²„í‚· ì „ì²´ë¥¼ ìˆœíšŒí•˜ë©´ì„œ ì¶œë ¥í•´ì£¼ëŠ” í•¨ìˆ˜ì´ë‹¤.
### main í•¨ìˆ˜
```c
int main(){
    // í•´ì‹œí…Œì´ë¸” ë©”ëª¨ë¦¬ í• ë‹¹
    hashTable = (struct bucket *)malloc(BUCKET_SIZE * sizeof(struct bucket));
}
```
#### ì´ì œ í•´ì‹œí…Œì´ë¸”ì— ì§ì ‘ ê°’ì„ ë„£ê³  ë¹¼ë©° í„°ë¯¸ë„ì— ì¶œë ¥í•œ ê²°ê³¼ê°’ì„ ë³´ì
#### iterm2ì—ì„œ gccë¡œ ì»´íŒŒì¼ í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì¶œë ¥í•˜ì˜€ë‹¤.
### ì»´íŒŒì¼
![](https://images.velog.io/images/jewelrykim/post/87c05bd1-62b5-4923-ac02-32785c125480/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.48.16.png)
-o [name] ì†ì„±ì„ ë¶™ì—¬ì„œ singleì´ë¼ëŠ” ì´ë¦„ìœ¼ë¡œ ì‹¤í–‰íŒŒì¼ì„ ë§Œë“¤ì—ˆë‹¤.
### ì¶œë ¥ ì‹¤í–‰
![](https://images.velog.io/images/jewelrykim/post/1bbb19dd-86eb-474c-9d95-c61619277cb7/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.48.41.png)
#### ë¨¼ì € ê°’ ì—¬ëŸ¬ê°œë¥¼ ë„£ê³  ì¶œë ¥í•´ë³´ì
```c
    // 15 ê¹Œì§€ ê°’ ì¶”ê°€
    for (int i=0; i < 16; i++){
        add(i, 10*i);
    }
    // ëª‡ê°œ ë” ì¶”ê°€
    add(21, 210);
    add(31, 310);
    add(41, 410);

    display();
```
![](https://images.velog.io/images/jewelrykim/post/9c172f3c-3bb0-4960-872d-a0a565cda44d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.50.38.png)
#### ê°’ ì—¬ëŸ¬ê°œë¥¼ ì‚­ì œí•´ë³´ê³  ì¶œë ¥í•´ë³´ì
```c
    remove_key(31);
    remove_key(11);
    remove_key(51);

    display();
```
![](https://images.velog.io/images/jewelrykim/post/5aca412d-1aa5-4573-a292-9043a3aca4a0/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.52.01.png)
#### search í•¨ìˆ˜ë„ ì‚¬ìš©í•´ë³´ì
```c
    search(11);
    search(1);
```
![](https://images.velog.io/images/jewelrykim/post/38f21fee-063c-42ee-ba51-fb1085ba66ee/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.53.53.png)

## 2 . doubly linked listë¡œ êµ¬í˜„
#### ìœ„ì—ì„œ êµ¬í˜„í•œ ë‚´ìš©ê³¼ ê±°ì˜ ë™ì¼í•˜ë‹ˆ ì°¨ì´ê°€ ìˆëŠ” ê³³ë§Œ ê¸€ë¡œ ì˜®ê¸°ë„ë¡ í•˜ê² ë‹¤.
### ë…¸ë“œ êµ¬ì¡°ì²´
```c
// ë…¸ë“œ êµ¬ì¡°ì²´ ì„ ì–¸
struct node {
    int key; // í•´ì‹œ í•¨ìˆ˜ì— ì‚¬ìš©ë  í‚¤
    int value; // key ê°€ ê°€ì§€ê³  ìˆëŠ” ë°ì´í„°
    struct node* next; // ë‹¤ìŒ ë…¸ë“œë¥¼ ê°€ë¥´í‚¤ëŠ” í¬ì¸í„°
    struct node* previous; // ì´ì „ ë…¸ë“œë¥¼ ê°€ë¥´í‚¤ëŠ” í¬ì¸í„°
};
```
ìƒˆë¡­ê²Œ previousë¼ëŠ” í¬ì¸í„°ê°€ ìƒê²¼ë‹¤. ë‹¹ì—°íˆ createNodeì—ì„œ previous í¬ì¸í„°ë„ NULLë¡œ ì´ˆê¸°í™” í•´ì¤€ë‹¤. ì´ í•¨ìˆ˜ ë¶€ë¶„ì€ ìƒëµí•œë‹¤.
### add í•¨ìˆ˜
```c
    // ë²„ì¼“ì— ë‹¤ë¥¸ ë…¸ë“œê°€ ìˆì„ ê²½ìš° í•œì¹¸ì”© ë°€ê³  ë‚´ê°€ í—¤ë“œê°€ ëœë‹¤(ì‹¤ì œë¡œëŠ” í¬ì¸í„°ë§Œ ë°”ê¿”ì¤Œ)
    else{
        hashTable[hashIndex].head->previous = newNode; // ì¶”ê°€
        newNode->next = hashTable[hashIndex].head;
        hashTable[hashIndex].head = newNode;
        hashTable[hashIndex].count++;
    }
```
add í•¨ìˆ˜ì—ì„œ elseë¶€ë¶„ì— í•œì¤„ì´ ì¶”ê°€ë˜ì—ˆë‹¤. í•œì¹¸ ë’¤ë¡œ ë°€ë ¤ë‚˜ê¸° ë•Œë¬¸ì— ìƒˆë¡­ê²Œ ë“¤ì–´ì˜¨ nodeê°€ ì›ë˜ ìˆë˜ headì˜ previousê°€ ëœë‹¤.
![](https://images.velog.io/images/jewelrykim/post/9023e8e4-0dbd-418b-a795-fbd32024113f/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%206.59.52.png)
### remove_keyí•¨ìˆ˜
```c
// í‚¤ë¥¼ ì‚­ì œí•´ì£¼ëŠ” í•¨ìˆ˜
void remove_key(int key){
    int hashIndex = hashFunction(key);
    // ì‚­ì œê°€ ë˜ì—ˆëŠ”ì§€ í™•ì¸í•˜ëŠ” flag ì„ ì–¸
    int flag = 0;
    // í‚¤ë¥¼ ì°¾ì•„ì¤„ iterator ì„ ì–¸
    struct node* node;
    // struct node* before; // í•„ìš” ì—†ìŒ!
    // ë²„ì¼“ì˜ headë¶€í„° ì‹œì‘
    node = hashTable[hashIndex].head;
    // ë²„ì¼“ì„ ìˆœíšŒí•˜ë©´ì„œ keyë¥¼ ì°¾ëŠ”ë‹¤.
    while (node != NULL) // NULL ì´ ë‚˜ì˜¬ë•Œê¹Œì§€ ìˆœíšŒ
    {
        if (node->key == key){
            // í¬ì¸í„° ë°”ê¿”ì£¼ê¸° ë…¸ë“œê°€ 1 . í—¤ë“œì¸ ê²½ìš° 2 . í—¤ë“œê°€ ì•„ë‹Œê²½ìš°
            if (node == hashTable[hashIndex].head){
                node->next->previous = NULL; // ì¶”ê°€ ì´ì œ ë‹¤ìŒê»˜ í—¤ë“œê°€ ë˜ì—ˆìœ¼ë¯€ë¡œ previousê°€ ì—†ìŒ
                hashTable[hashIndex].head = node->next; // ë‹¤ìŒ ë…¸ë“œê°€ ì´ì œ í—¤ë“œ
            }
            else{
                node->previous->next = node->next; // ë‚´ ì „ ë…¸ë“œì˜ ì•ì´ ì´ì œ ë‚´ ì• ë…¸ë“œ
                node->next->previous = node->previous; // ë‚´ ì• ë…¸ë“œì˜ ì „ì´ ì´ì œ ë‚´ ì „ ë…¸ë“œ
            }
            // ë‚˜ë¨¸ì§€ ì‘ì—… ìˆ˜í–‰
            hashTable[hashIndex].count--;
            free(node);
            flag = 1;
        }
        node = node->next;
    }
    // flagì˜ ê°’ì— ë”°ë¼ ì¶œë ¥ ë‹¤ë¥´ê²Œ í•´ì¤Œ
    if (flag == 1){ // ì‚­ì œê°€ ë˜ì—ˆë‹¤ë©´
        printf("\n [ %d ] ì´/ê°€ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤. \n", key);
    }
    else{ // í‚¤ê°€ ì—†ì–´ì„œ ì‚­ì œê°€ ì•ˆëœ ê²½ìš°
        printf("\n [ %d ] ì´/ê°€ ì¡´ì¬í•˜ì§€ ì•Šì•„ ì‚­ì œí•˜ì§€ ëª»í–ˆìŠµë‹ˆë‹¤.\n", key);
    }
}
```
ì¼ë‹¨ ì§€ë‚˜ì˜¨ ë…¸ë“œë¥¼ ì €ì¥í•˜ë˜ beforeëŠ” í•„ìš”ê°€ ì—†ê²Œë˜ì—ˆë‹¤. ê·¸ë¦¬ê³  í¬ì¸í„°ë¥¼ ë°”ê¿”ì¤„ ë•Œ previousë¡œ ë°”ë¡œ ì ‘ê·¼í•˜ì—¬ í¬ì¸í„°ë¥¼ ë°”ê¿”ì£¼ëŠ” ë°©ì‹ìœ¼ë¡œ ìˆ˜ì •ë˜ì—ˆë‹¤.
#### ë‚˜ë¨¸ì§€ëŠ” ë™ì¼í•˜ë‹¤.
![](https://images.velog.io/images/jewelrykim/post/cecac623-36c3-411c-bf41-cf582622474d/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202021-05-11%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%208.55.44.png)
ì¶œë ¥ë„ ë™ì¼í•¨ì„ ì•Œ ìˆ˜ ìˆë‹¤. doubly linked listì—ëŠ” -> í™”ì‚´í‘œê°€ ì•„ë‹Œ <-> í™”ì‚´í‘œë¥¼ ì¶œë ¥í•´ ì°¨ë³„ì ì„ ë‘ì—ˆë‹¤ :)

#### ì‹¤ì œë¡œ êµ¬í˜„ê¹Œì§€ í•´ë³´ë‹ˆ ì‚¬ìš©í–ˆì„ ì  ì¼ì–´ë‚¬ë˜ ì¼ë“¤ì´ ë”ìš± ì´í•´ê°€ ì˜ ëœë‹¤. êµ¬í˜„í•œ ì½”ë“œëŠ” ì•„ë˜ ê¹ƒí—™ì— ë‚¨ê¸´ë‹¤. ì´ ê¸€ì„ ëˆ„êµ°ê°€ ë³¸ë‹¤ë©´ ì–´ë µì§€ ì•Šìœ¼ë‹ˆ ê¼­ í•œë²ˆ ì§ì ‘ êµ¬í˜„í•´ë³´ê¸¸ ì¶”ì²œí•©ë‹ˆë‹¤! ğŸ˜† 
[github ë§í¬](https://github.com/jewerlykim/HashtableImplementationByC)
